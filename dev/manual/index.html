<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Manual · Dualization.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../"><img class="logo" src="../assets/logo.png" alt="Dualization.jl logo"/></a><h1>Dualization.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li class="current"><a class="toctext" href>Manual</a><ul class="internal"><li><a class="toctext" href="#Conic-Duality-1">Conic Duality</a></li><li><a class="toctext" href="#Supported-constraints-1">Supported constraints</a></li><li><a class="toctext" href="#Supported-objective-functions-1">Supported objective functions</a></li><li><a class="toctext" href="#Dualize-a-model-1">Dualize a model</a></li><li><a class="toctext" href="#DualOptimizer-1">DualOptimizer</a></li><li><a class="toctext" href="#Adding-new-sets-1">Adding new sets</a></li></ul></li><li><a class="toctext" href="../examples/">Examples</a></li><li><a class="toctext" href="../reference/">Reference</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Manual</a></li></ul><a class="edit-page" href="https://github.com/JuliaOpt/Dualization.jl/blob/master/docs/src/manual.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Manual</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Manual-1" href="#Manual-1">Manual</a></h1><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>This package only works for optimization models that can be written in the conic-form.</p></div></div><h2><a class="nav-anchor" id="Conic-Duality-1" href="#Conic-Duality-1">Conic Duality</a></h2><p>Conic duality is the starting point for MOI&#39;s duality conventions. When all functions are affine (or coordinate projections), and all constraint sets are closed convex cones, the model may be called a conic optimization problem. For conic-form minimization problems, the primal is:</p><div>\[\begin{align}
&amp; \min_{x \in \mathbb{R}^n} &amp; a_0^T x + b_0
\\
&amp; \;\;\text{s.t.} &amp; A_i x + b_i &amp; \in \mathcal{C}_i &amp; i = 1 \ldots m
\end{align}\]</div><p>and the dual is:</p><div>\[\begin{align}
&amp; \max_{y_1, \ldots, y_m} &amp; -\sum_{i=1}^m b_i^T y_i + b_0
\\
&amp; \;\;\text{s.t.} &amp; a_0 - \sum_{i=1}^m A_i^T y_i &amp; = 0
\\
&amp; &amp; y_i &amp; \in \mathcal{C}_i^* &amp; i = 1 \ldots m
\end{align}\]</div><p>where each <span>$\mathcal{C}_i$</span> is a closed convex cone and <span>$\mathcal{C}_i^*$</span> is its dual cone.</p><p>For conic-form maximization problems, the primal is:</p><div>\[\begin{align}
&amp; \max_{x \in \mathbb{R}^n} &amp; a_0^T x + b_0
\\
&amp; \;\;\text{s.t.} &amp; A_i x + b_i &amp; \in \mathcal{C}_i &amp; i = 1 \ldots m
\end{align}\]</div><p>and the dual is:</p><div>\[\begin{align}
&amp; \min_{y_1, \ldots, y_m} &amp; \sum_{i=1}^m b_i^T y_i + b_0
\\
&amp; \;\;\text{s.t.} &amp; a_0 + \sum_{i=1}^m A_i^T y_i &amp; = 0
\\
&amp; &amp; y_i &amp; \in \mathcal{C}_i^* &amp; i = 1 \ldots m
\end{align}\]</div><p>A linear inequality constraint <span>$a^T x + b \ge c$</span> should be interpreted as <span>$a^T x + b - c \in \mathbb{R}_+$</span>, and similarly <span>$a^T x + b \le c$</span> should be interpreted as <span>$a^T x + b - c \in \mathbb{R}_-$</span>. Variable-wise constraints should be interpreted as affine constraints with the appropriate identity mapping in place of <span>$A_i$</span>.</p><p>For the special case of minimization LPs, the MOI primal form can be stated as</p><div>\[\begin{align}
&amp; \min_{x \in \mathbb{R}^n} &amp; a_0^T x &amp;+ b_0
\\
&amp; \;\;\text{s.t.}
&amp;A_1 x &amp; \ge b_1\\
&amp;&amp; A_2 x &amp; \le b_2\\
&amp;&amp; A_3 x &amp; = b_3
\end{align}\]</div><p>By applying the stated transformations to conic form, taking the dual, and transforming back into linear inequality form, one obtains the following dual:</p><div>\[\begin{align}
&amp; \max_{y_1,y_2,y_3} &amp; b_1^Ty_1 + b_2^Ty_2 + b_3^Ty_3 &amp;+ b_0
\\
&amp; \;\;\text{s.t.}
&amp;A_1^Ty_1 + A_2^Ty_2 + A_3^Ty_3 &amp; = a_0\\
&amp;&amp; y_1 &amp;\ge 0\\
&amp;&amp; y_2 &amp;\le 0
\end{align}\]</div><p>For maximization LPs, the MOI primal form can be stated as:</p><div>\[\begin{align}
&amp; \max_{x \in \mathbb{R}^n} &amp; a_0^T x &amp;+ b_0
\\
&amp; \;\;\text{s.t.}
&amp;A_1 x &amp; \ge b_1\\
&amp;&amp; A_2 x &amp; \le b_2\\
&amp;&amp; A_3 x &amp; = b_3
\end{align}\]</div><p>and similarly, the dual is:</p><div>\[\begin{align}
&amp; \min_{y_1,y_2,y_3} &amp; -b_1^Ty_1 - b_2^Ty_2 - b_3^Ty_3 &amp;+ b_0
\\
&amp; \;\;\text{s.t.}
&amp;A_1^Ty_1 + A_2^Ty_2 + A_3^Ty_3 &amp; = -a_0\\
&amp;&amp; y_1 &amp;\ge 0\\
&amp;&amp; y_2 &amp;\le 0
\end{align}\]</div><h2><a class="nav-anchor" id="Supported-constraints-1" href="#Supported-constraints-1">Supported constraints</a></h2><p>This is the list of supported <code>Function-in-Set</code> constraints of the package. If you try to dualize a constraint not listed here, it will return an usupported error.</p><table><tr><th style="text-align: left">MOI Function</th><th style="text-align: left">MOI Set</th></tr><tr><td style="text-align: left"><code>SingleVariable</code></td><td style="text-align: left"><code>GreaterThan</code></td></tr><tr><td style="text-align: left"><code>SingleVariable</code></td><td style="text-align: left"><code>LessThan</code></td></tr><tr><td style="text-align: left"><code>SingleVariable</code></td><td style="text-align: left"><code>EqualTo</code></td></tr><tr><td style="text-align: left"><code>ScalarAffineFunction</code></td><td style="text-align: left"><code>GreaterThan</code></td></tr><tr><td style="text-align: left"><code>ScalarAffineFunction</code></td><td style="text-align: left"><code>LessThan</code></td></tr><tr><td style="text-align: left"><code>ScalarAffineFunction</code></td><td style="text-align: left"><code>EqualTo</code></td></tr><tr><td style="text-align: left"><code>VectorOfVariables</code></td><td style="text-align: left"><code>Nonnegatives</code></td></tr><tr><td style="text-align: left"><code>VectorOfVariables</code></td><td style="text-align: left"><code>Nonpositives</code></td></tr><tr><td style="text-align: left"><code>VectorOfVariables</code></td><td style="text-align: left"><code>Zeros</code></td></tr><tr><td style="text-align: left"><code>VectorOfVariables</code></td><td style="text-align: left"><code>SecondOrderCone</code></td></tr><tr><td style="text-align: left"><code>VectorOfVariables</code></td><td style="text-align: left"><code>RotatedSecondOrderCone</code></td></tr><tr><td style="text-align: left"><code>VectorOfVariables</code></td><td style="text-align: left"><code>PositiveSemidefiniteConeTriangle</code></td></tr><tr><td style="text-align: left"><code>VectorOfVariables</code></td><td style="text-align: left"><code>ExponentialCone</code></td></tr><tr><td style="text-align: left"><code>VectorOfVariables</code></td><td style="text-align: left"><code>DualExponentialCone</code></td></tr><tr><td style="text-align: left"><code>VectorOfVariables</code></td><td style="text-align: left"><code>PowerCone</code></td></tr><tr><td style="text-align: left"><code>VectorOfVariables</code></td><td style="text-align: left"><code>DualPowerCone</code></td></tr><tr><td style="text-align: left"><code>VectorAffineFunction</code></td><td style="text-align: left"><code>Nonnegatives</code></td></tr><tr><td style="text-align: left"><code>VectorAffineFunction</code></td><td style="text-align: left"><code>Nonpositives</code></td></tr><tr><td style="text-align: left"><code>VectorAffineFunction</code></td><td style="text-align: left"><code>Zeros</code></td></tr><tr><td style="text-align: left"><code>VectorAffineFunction</code></td><td style="text-align: left"><code>SecondOrderCone</code></td></tr><tr><td style="text-align: left"><code>VectorAffineFunction</code></td><td style="text-align: left"><code>RotatedSecondOrderCone</code></td></tr><tr><td style="text-align: left"><code>VectorAffineFunction</code></td><td style="text-align: left"><code>PositiveSemidefiniteConeTriangle</code></td></tr><tr><td style="text-align: left"><code>VectorAffineFunction</code></td><td style="text-align: left"><code>ExponentialCone</code></td></tr><tr><td style="text-align: left"><code>VectorAffineFunction</code></td><td style="text-align: left"><code>DualExponentialCone</code></td></tr><tr><td style="text-align: left"><code>VectorAffineFunction</code></td><td style="text-align: left"><code>PowerCone</code></td></tr><tr><td style="text-align: left"><code>VectorAffineFunction</code></td><td style="text-align: left"><code>DualPowerCone</code></td></tr></table><p>Note that some of MOI constraints can be bridged, see <a href="http://www.juliaopt.org/MathOptInterface.jl/stable/apireference/#Bridges-1">Bridges</a>, to constraints in this list.</p><h2><a class="nav-anchor" id="Supported-objective-functions-1" href="#Supported-objective-functions-1">Supported objective functions</a></h2><table><tr><th style="text-align: center">MOI Function</th></tr><tr><td style="text-align: center"><code>SingleVariable</code></td></tr><tr><td style="text-align: center"><code>ScalarAffineFunction</code></td></tr></table><h2><a class="nav-anchor" id="Dualize-a-model-1" href="#Dualize-a-model-1">Dualize a model</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dualization.dualize" href="#Dualization.dualize"><code>Dualization.dualize</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">dualize(args...; kwargs...)</code></pre><p>The <code>dualize</code> function works in three different ways. The user can provide:</p><ul><li>A <code>MathOptInterface.ModelLike</code></li></ul><p>The function will return a <code>DualProblem</code> struct that has the dualized model and <code>PrimalDualMap{Float64}</code> for users to identify the links between primal and dual model.</p><ul><li><p>A <code>MathOptInterface.ModelLike</code> and a <code>DualProblem{T}</code></p></li><li><p>A <code>JuMP.Model</code></p></li></ul><p>The function will return a JuMP model with the dual representation of the problem.</p><ul><li>A <code>JuMP.Model</code> and an optimizer factory</li></ul><p>The function will return a JuMP model with the dual representation of the problem with  the <code>OptimizerFactory</code> attached. The <code>OptimizerFactory</code> is the solver and its key arguments that users provide in JuMP models, i.e. <code>with_optimizer(GLPK.Optimizer)</code>.</p><p>On each of these methods, the user can provide the keyword argument <code>dual_names</code>. <code>dual_names</code> must be a <code>DualNames</code> struct. It allows users to set more intuitive names  for the dual variables and dual constraints created.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/Dualization.jl/blob/d6d36dee41688cd1bfb4d0a15e17cf28998b526f/src/dualize.jl#L74-L99">source</a></section><h2><a class="nav-anchor" id="DualOptimizer-1" href="#DualOptimizer-1">DualOptimizer</a></h2><p>You can solve a primal problem by using its dual formulation. ADD EXAMPLE.</p><h2><a class="nav-anchor" id="Adding-new-sets-1" href="#Adding-new-sets-1">Adding new sets</a></h2><p>Dualization.jl can automatically dualize models with custom sets. To do this, the user needs to define the set and its dual set in MathOptInterface.jl and provide the functions <code>dual_set</code> and <code>set_dot</code> for the set the user wants to dualize.</p><p>ADD EXAMPLE</p><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="../examples/"><span class="direction">Next</span><span class="title">Examples</span></a></footer></article></body></html>
