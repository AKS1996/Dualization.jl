<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Manual · Dualization.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><nav class="toc"><a href="../"><img class="logo" src="../assets/logo.png" alt="Dualization.jl logo"/></a><h1>Dualization.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li class="current"><a class="toctext" href>Manual</a><ul class="internal"><li><a class="toctext" href="#Conic-Duality-1">Conic Duality</a></li><li><a class="toctext" href="#Supported-constraints-1">Supported constraints</a></li><li><a class="toctext" href="#Supported-objective-functions-1">Supported objective functions</a></li><li><a class="toctext" href="#Dualize-a-model-1">Dualize a model</a></li><li><a class="toctext" href="#DualOptimizer-1">DualOptimizer</a></li><li><a class="toctext" href="#Adding-new-sets-1">Adding new sets</a></li></ul></li><li><a class="toctext" href="../examples/">Examples</a></li><li><a class="toctext" href="../reference/">Reference</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Manual</a></li></ul><a class="edit-page" href="https://github.com/JuliaOpt/Dualization.jl/blob/master/docs/src/manual.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Manual</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Manual-1" href="#Manual-1">Manual</a></h1><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>This package only works for optimization models that can be written in the conic-form.</p></div></div><h2><a class="nav-anchor" id="Conic-Duality-1" href="#Conic-Duality-1">Conic Duality</a></h2><p>Conic duality is the starting point for MOI&#39;s duality conventions. When all functions are affine (or coordinate projections), and all constraint sets are closed convex cones, the model may be called a conic optimization problem. For conic-form minimization problems, the primal is:</p><div>\[\begin{align}
&amp; \min_{x \in \mathbb{R}^n} &amp; a_0^T x + b_0
\\
&amp; \;\;\text{s.t.} &amp; A_i x + b_i &amp; \in \mathcal{C}_i &amp; i = 1 \ldots m
\end{align}\]</div><p>and the dual is:</p><div>\[\begin{align}
&amp; \max_{y_1, \ldots, y_m} &amp; -\sum_{i=1}^m b_i^T y_i + b_0
\\
&amp; \;\;\text{s.t.} &amp; a_0 - \sum_{i=1}^m A_i^T y_i &amp; = 0
\\
&amp; &amp; y_i &amp; \in \mathcal{C}_i^* &amp; i = 1 \ldots m
\end{align}\]</div><p>where each <span>$\mathcal{C}_i$</span> is a closed convex cone and <span>$\mathcal{C}_i^*$</span> is its dual cone.</p><p>For conic-form maximization problems, the primal is:</p><div>\[\begin{align}
&amp; \max_{x \in \mathbb{R}^n} &amp; a_0^T x + b_0
\\
&amp; \;\;\text{s.t.} &amp; A_i x + b_i &amp; \in \mathcal{C}_i &amp; i = 1 \ldots m
\end{align}\]</div><p>and the dual is:</p><div>\[\begin{align}
&amp; \min_{y_1, \ldots, y_m} &amp; \sum_{i=1}^m b_i^T y_i + b_0
\\
&amp; \;\;\text{s.t.} &amp; a_0 + \sum_{i=1}^m A_i^T y_i &amp; = 0
\\
&amp; &amp; y_i &amp; \in \mathcal{C}_i^* &amp; i = 1 \ldots m
\end{align}\]</div><p>A linear inequality constraint <span>$a^T x + b \ge c$</span> should be interpreted as <span>$a^T x + b - c \in \mathbb{R}_+$</span>, and similarly <span>$a^T x + b \le c$</span> should be interpreted as <span>$a^T x + b - c \in \mathbb{R}_-$</span>. Variable-wise constraints should be interpreted as affine constraints with the appropriate identity mapping in place of <span>$A_i$</span>.</p><p>For the special case of minimization LPs, the MOI primal form can be stated as</p><div>\[\begin{align}
&amp; \min_{x \in \mathbb{R}^n} &amp; a_0^T x &amp;+ b_0
\\
&amp; \;\;\text{s.t.}
&amp;A_1 x &amp; \ge b_1\\
&amp;&amp; A_2 x &amp; \le b_2\\
&amp;&amp; A_3 x &amp; = b_3
\end{align}\]</div><p>By applying the stated transformations to conic form, taking the dual, and transforming back into linear inequality form, one obtains the following dual:</p><div>\[\begin{align}
&amp; \max_{y_1,y_2,y_3} &amp; b_1^Ty_1 + b_2^Ty_2 + b_3^Ty_3 &amp;+ b_0
\\
&amp; \;\;\text{s.t.}
&amp;A_1^Ty_1 + A_2^Ty_2 + A_3^Ty_3 &amp; = a_0\\
&amp;&amp; y_1 &amp;\ge 0\\
&amp;&amp; y_2 &amp;\le 0
\end{align}\]</div><p>For maximization LPs, the MOI primal form can be stated as:</p><div>\[\begin{align}
&amp; \max_{x \in \mathbb{R}^n} &amp; a_0^T x &amp;+ b_0
\\
&amp; \;\;\text{s.t.}
&amp;A_1 x &amp; \ge b_1\\
&amp;&amp; A_2 x &amp; \le b_2\\
&amp;&amp; A_3 x &amp; = b_3
\end{align}\]</div><p>and similarly, the dual is:</p><div>\[\begin{align}
&amp; \min_{y_1,y_2,y_3} &amp; -b_1^Ty_1 - b_2^Ty_2 - b_3^Ty_3 &amp;+ b_0
\\
&amp; \;\;\text{s.t.}
&amp;A_1^Ty_1 + A_2^Ty_2 + A_3^Ty_3 &amp; = -a_0\\
&amp;&amp; y_1 &amp;\ge 0\\
&amp;&amp; y_2 &amp;\le 0
\end{align}\]</div><h2><a class="nav-anchor" id="Supported-constraints-1" href="#Supported-constraints-1">Supported constraints</a></h2><p>This is the list of supported <code>Function-in-Set</code> constraints of the package. If you try to dualize a constraint not listed here, it will return an unsupported error.</p><table><tr><th style="text-align: left">MOI Function</th><th style="text-align: left">MOI Set</th></tr><tr><td style="text-align: left"><code>SingleVariable</code></td><td style="text-align: left"><code>GreaterThan</code></td></tr><tr><td style="text-align: left"><code>SingleVariable</code></td><td style="text-align: left"><code>LessThan</code></td></tr><tr><td style="text-align: left"><code>SingleVariable</code></td><td style="text-align: left"><code>EqualTo</code></td></tr><tr><td style="text-align: left"><code>ScalarAffineFunction</code></td><td style="text-align: left"><code>GreaterThan</code></td></tr><tr><td style="text-align: left"><code>ScalarAffineFunction</code></td><td style="text-align: left"><code>LessThan</code></td></tr><tr><td style="text-align: left"><code>ScalarAffineFunction</code></td><td style="text-align: left"><code>EqualTo</code></td></tr><tr><td style="text-align: left"><code>VectorOfVariables</code></td><td style="text-align: left"><code>Nonnegatives</code></td></tr><tr><td style="text-align: left"><code>VectorOfVariables</code></td><td style="text-align: left"><code>Nonpositives</code></td></tr><tr><td style="text-align: left"><code>VectorOfVariables</code></td><td style="text-align: left"><code>Zeros</code></td></tr><tr><td style="text-align: left"><code>VectorOfVariables</code></td><td style="text-align: left"><code>SecondOrderCone</code></td></tr><tr><td style="text-align: left"><code>VectorOfVariables</code></td><td style="text-align: left"><code>RotatedSecondOrderCone</code></td></tr><tr><td style="text-align: left"><code>VectorOfVariables</code></td><td style="text-align: left"><code>PositiveSemidefiniteConeTriangle</code></td></tr><tr><td style="text-align: left"><code>VectorOfVariables</code></td><td style="text-align: left"><code>ExponentialCone</code></td></tr><tr><td style="text-align: left"><code>VectorOfVariables</code></td><td style="text-align: left"><code>DualExponentialCone</code></td></tr><tr><td style="text-align: left"><code>VectorOfVariables</code></td><td style="text-align: left"><code>PowerCone</code></td></tr><tr><td style="text-align: left"><code>VectorOfVariables</code></td><td style="text-align: left"><code>DualPowerCone</code></td></tr><tr><td style="text-align: left"><code>VectorAffineFunction</code></td><td style="text-align: left"><code>Nonnegatives</code></td></tr><tr><td style="text-align: left"><code>VectorAffineFunction</code></td><td style="text-align: left"><code>Nonpositives</code></td></tr><tr><td style="text-align: left"><code>VectorAffineFunction</code></td><td style="text-align: left"><code>Zeros</code></td></tr><tr><td style="text-align: left"><code>VectorAffineFunction</code></td><td style="text-align: left"><code>SecondOrderCone</code></td></tr><tr><td style="text-align: left"><code>VectorAffineFunction</code></td><td style="text-align: left"><code>RotatedSecondOrderCone</code></td></tr><tr><td style="text-align: left"><code>VectorAffineFunction</code></td><td style="text-align: left"><code>PositiveSemidefiniteConeTriangle</code></td></tr><tr><td style="text-align: left"><code>VectorAffineFunction</code></td><td style="text-align: left"><code>ExponentialCone</code></td></tr><tr><td style="text-align: left"><code>VectorAffineFunction</code></td><td style="text-align: left"><code>DualExponentialCone</code></td></tr><tr><td style="text-align: left"><code>VectorAffineFunction</code></td><td style="text-align: left"><code>PowerCone</code></td></tr><tr><td style="text-align: left"><code>VectorAffineFunction</code></td><td style="text-align: left"><code>DualPowerCone</code></td></tr></table><p>Note that some of MOI constraints can be bridged, see <a href="http://www.juliaopt.org/MathOptInterface.jl/stable/apireference/#Bridges-1">Bridges</a>, to constraints in this list.</p><h2><a class="nav-anchor" id="Supported-objective-functions-1" href="#Supported-objective-functions-1">Supported objective functions</a></h2><table><tr><th style="text-align: center">MOI Function</th></tr><tr><td style="text-align: center"><code>SingleVariable</code></td></tr><tr><td style="text-align: center"><code>ScalarAffineFunction</code></td></tr></table><h2><a class="nav-anchor" id="Dualize-a-model-1" href="#Dualize-a-model-1">Dualize a model</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dualization.dualize" href="#Dualization.dualize"><code>Dualization.dualize</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">dualize(args...; kwargs...)</code></pre><p>The <code>dualize</code> function works in three different ways. The user can provide:</p><ul><li>A <code>MathOptInterface.ModelLike</code></li></ul><p>The function will return a <code>DualProblem</code> struct that has the dualized model and <code>PrimalDualMap{Float64}</code> for users to identify the links between primal and dual model.</p><ul><li><p>A <code>MathOptInterface.ModelLike</code> and a <code>DualProblem{T}</code></p></li><li><p>A <code>JuMP.Model</code></p></li></ul><p>The function will return a JuMP model with the dual representation of the problem.</p><ul><li>A <code>JuMP.Model</code> and an optimizer factory</li></ul><p>The function will return a JuMP model with the dual representation of the problem with  the <code>OptimizerFactory</code> attached. The <code>OptimizerFactory</code> is the solver and its key arguments that users provide in JuMP models, i.e. <code>with_optimizer(GLPK.Optimizer)</code>.</p><p>On each of these methods, the user can provide the keyword argument <code>dual_names</code>. <code>dual_names</code> must be a <code>DualNames</code> struct. It allows users to set more intuitive names  for the dual variables and dual constraints created.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/Dualization.jl/blob/57f0d7e838eb776ae616c5ec61a60af5b113a99a/src/dualize.jl#L74-L99">source</a></section><h2><a class="nav-anchor" id="DualOptimizer-1" href="#DualOptimizer-1">DualOptimizer</a></h2><p>You can solve a primal problem by using its dual formulation using the <code>DualOptimizer</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dualization.DualOptimizer" href="#Dualization.DualOptimizer"><code>Dualization.DualOptimizer</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">DualOptimizer(dual_optimizer::OT) where {OT &lt;: MOI.ModelLike}</code></pre><p>The DualOptimizer finds the solution for a problem solving its dual representation. It builds the dual model and solve it using the <code>dual_optimizer</code> as solver.</p><p>The user can define the model providing the <code>DualOptimizer</code> and the solver of its choice</p><pre><code class="language-julia">julia&gt; using Dualization, JuMP, GLPK

julia&gt; model = Model(with_optimizer(DualOptimizer, GLPK.Optimizer()))
A JuMP Model
Feasibility problem with:
Variables: 0
Model mode: AUTOMATIC
CachingOptimizer state: EMPTY_OPTIMIZER
Solver name: Dual model with GLPK attached</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/Dualization.jl/blob/57f0d7e838eb776ae616c5ec61a60af5b113a99a/src/MOI_wrapper.jl#L25-L44">source</a></section><h2><a class="nav-anchor" id="Adding-new-sets-1" href="#Adding-new-sets-1">Adding new sets</a></h2><p>Dualization.jl can automatically dualize models with custom sets. To do this, the user needs to define the set and its dual set and provide the functions:</p><ul><li><code>supported_constraint</code></li><li><code>dual_set</code> </li></ul><p>If the custom set has some special scalar product (see the <a href="https://www.juliaopt.org/MathOptInterface.jl/stable/apireference/#MathOptInterface.AbstractSymmetricMatrixSetTriangle">link</a>), the user also needs to provide a <code>set_dot</code> function.</p><p>For example, let us define a fake cone and its dual, the fake dual cone. We will write a JuMP model with the fake cone and dualize it.</p><pre><code class="language-julia">using Dualization, JuMP, MathOptInterface, LinearAlgebra

# Rename MathOptInterface to simplify the code
const MOI = MathOptInterface

# Define the custom cone and its dual
struct FakeCone &lt;: MOI.AbstractVectorSet
    dimension::Int
end

struct FakeDualCone &lt;: MOI.AbstractVectorSet
    dimension::Int
end

# Define a model with your FakeCone
model = Model()
@variable(model, x[1:3])
@constraint(model, con, x in FakeCone(3)) # Note that the constraint name is &quot;con&quot;
@objective(model, Min, sum(x))</code></pre><p>The resulting JuMP model is</p><div>\[\begin{align}
    &amp; \min_{x} &amp; x_1 + x_2 + x_3 &amp;
    \\
    &amp; \;\;\text{s.t.}
    &amp;x \in FakeCone(3)\\
\end{align}\]</div><p>Now in order to dualize we must overload the methods as described above.</p><pre><code class="language-julia"># Overload the methods dual_set and supported_constraints
Dualization.dual_set(s::FakeCone) = FakeDualCone(MOI.dimension(s))
Dualization.supported_constraint(::Type{MOI.VectorOfVariables}, ::Type{&lt;:FakeCone}) = true

# If your set has some specific scalar product you also need to define a new set_dot function
# Our FakeCone has this weird scalar product
MOI.Utilities.set_dot(x::Vector, y::Vector, set::FakeCone) = 2dot(x, y)

# Dualize the model
dual_model = dualize(model)</code></pre><p>The resulting dual model is </p><div>\[\begin{align}
    &amp; \max_{con} &amp; 0 &amp;
    \\
    &amp; \;\;\text{s.t.}
    &amp;2con_1 &amp; = 1\\
    &amp;&amp;2con_2 &amp; = 1\\
    &amp;&amp;2con_3 &amp; = 1\\
    &amp;&amp; con &amp; \in FakeDualCone(3)\\
\end{align}\]</div><p>If the model has constraints that are <code>MOI.VectorAffineFunction</code></p><pre><code class="language-julia">model = Model()
@variable(model, x[1:3])
@constraint(model, con, x + 3 in FakeCone(3))
@objective(model, Min, sum(x))</code></pre><div>\[\begin{align}
    &amp; \min_{x} &amp; x_1 + x_2 + x_3 &amp;
    \\
    &amp; \;\;\text{s.t.}
    &amp;[x_1 + 3, x_2 + 3, x_3 + 3] &amp; \in FakeCone(3)\\
\end{align}\]</div><p>the user only needs to extend the <code>supported_constraints</code> function.</p><pre><code class="language-julia"># Overload the supported_constraints for VectorAffineFunction
Dualization.supported_constraint(::Type{&lt;:MOI.VectorAffineFunction}, ::Type{&lt;:FakeCone}) = true

# Dualize the model
dual_model = dualize(model)</code></pre><p>The resulting dual model is</p><div>\[\begin{align}
    &amp; \max_{con} &amp; - 3con_1&amp; - 3con_2 - 3con_3 
    \\
    &amp; \;\;\text{s.t.}
    &amp;2con_1 &amp; = 1\\
    &amp;&amp;2con_2 &amp; = 1\\
    &amp;&amp;2con_3 &amp; = 1\\
    &amp;&amp; con &amp; \in FakeDualCone(3)\\
\end{align}\]</div><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="../examples/"><span class="direction">Next</span><span class="title">Examples</span></a></footer></article></body></html>
